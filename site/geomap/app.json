[{"name": "app.py", "content": "# Ecodistrict source: https://sis.agr.gc.ca/cansis/publications/maps/eco/all/districts/index.html\n\n\n#\n# -----RUN WEBASSMEBLY-----\n# This file contains the ShinyLive application for choropleth + coordinate maps.\n# It can be run with the following command within this directory:\n#\t\tshinylive export . [site]\n# Where [site] is the destination of the site folder.\n#\n# -----RUN PYTHON-----\n# If you would rather deploy the application as a PyShiny application,\n# run the following command within this directory:\n#\t\tshiny run\n#\n\n\nfrom shiny import App, reactive, render, ui\nfrom folium import Map as FoliumMap, Circle, GeoJson, Rectangle\nfrom folium.features import GeoJsonTooltip, GeoJsonPopup\nfrom folium.plugins import HeatMap as FoliumHeatMap\nfrom geopandas import GeoDataFrame\nfrom pandas import DataFrame\nfrom branca.colormap import LinearColormap\nfrom scipy.stats import gaussian_kde\nfrom numpy import vstack\nimport re\n\nfrom shared import Cache, Colors, Inlineify, NavBar, MainTab, Pyodide, Filter, ColumnType, TableOptions, Raw, InitializeConfig, ColorMaps, Error, Update, Msg, File\nfrom geojson import Mappings\n\ntry:\n\tfrom user import config\nexcept ImportError:\n\tfrom config import config\n\n# Required for Shiny\nimport branca, certifi, xyzservices\n\nURL = f\"{Raw}/geomap/data/\" if Pyodide else \"../data/\"\n\ndef server(input, output, session):\n\tnew_load_flag = reactive.value(False)\n\t@reactive.effect\n\tdef set_load_flag():\n\t\tnew_load_flag.set(True)\n\n\tInfoChoropleth = {\n\t\t\"Backyard_Hens_and_Bees.csv\": '''<u>Input type:</u> .csv Data <br><u>Contents:</u> Number of properties with hens or bees in Edmonton, by neighbourhood.''',\n\t\t\"FormerMunicipalities.csv\": '''<u>Input type:</u> .csv Data<br> <u>Contents:</u> Former municipalities absorbed by the city of Edmonton. <br><u>Source:</u> <a href=\"https://en.wikipedia.org/wiki/List_of_neighbourhoods_in_Edmonton\"; target=\"_blank\">Wikipedia</a>''',\n\t}\n\n\tdef HandleData(paths:list, p=None):\n\t\t\"\"\"\n\t\t@brief A custom Data Handler for the Cache.\n\t\t@param paths: Paths to files to load\n\t\t@returns A data object from the cache.\n\t\t@info This Data Handler supports geojson files as json\n\t\t\"\"\"\n\t\t# load the file(s) as a dataframe\n\t\treturn DataCache.DefaultHandler(paths)\n\tDataCache = Cache(\"geomap\", DataHandler=HandleData)\n\tDataChoropleth = reactive.value(None)\n\tValid = reactive.value(False)\n\tJSON = reactive.value(None)\n\tDataCoordinate = reactive.value(None)\n\n\tInitializeConfig(config, input)\n\n\n\tdef GetNameFromPath(filepath:str) -> str:\n\t\t\"\"\"\n\t\t@brief Given a filepath, extract the file name with no extension\n\t\t\"\"\"\n\t\t# TODO: user pathlib instead\n\t\tfilename = filepath.split(\"/\")[-1]\n\t\treturn filename.split(\".\")[0]\n\n\n\tasync def MakeColumnSelectors(name, key, val, choice):\n\t\t\"\"\"\n\t\t@brief Create ui elements to select a name and value column from choropleth data files\n\t\t\"\"\"\n\t\ttry:\n\t\t\t# remove old ui elements and labels\n\t\t\tui.remove_ui(selector=f\"#{name}_column_select\")\n\t\texcept Exception as e:\n\t\t\tprint(f\"Error removing previous column selectors for {name}:\\n{e}\")\n\n\t\tkey_ui = ui.input_select(\n\t\t\tid=f\"KeyColumn{name}\",\n\t\t\tlabel=f\"Location Names\", \n\t\t\tchoices=[key],\n\t\t\t#selected=key,\n\t\t\t)\n\t\tval_ui = ui.input_select(\n\t\t\tid=f\"ValueColumn{name}\", \n\t\t\tlabel=f\"Value Column\", \n\t\t\tchoices=val,\n\t\t\tselected=val[choice],\n\t\t\t)\n\t\taccordion = ui.accordion(\n\t\t\t\tui.accordion_panel(\n\t\t\t\t\tf\"{name}\",\n\t\t\t\t\tui.input_checkbox_group(id=f\"Disable{name}\", inline=False, label=None, choices=[\"Disable Layer\"], selected=None),\n\t\t\t\t\tkey_ui,\n\t\t\t\t\tval_ui,\n\t\t\t\t\t# ui.input_slider(id=f\"OpacityChoro{name}\", label=\"Opacity\", min=0.0, max=1.0, step=0.1),\n\t\t\t\t), \n\t\t\t\tid=f\"{name}_column_select\"\n\t\t\t)\n\t\tui.insert_ui(\n\t\t\taccordion,\n\t\t\tselector=\"#ChoroplethSettings\",\n\t\t\twhere=\"beforeEnd\",\n\t\t)\n\n\n\tasync def MakeColorSelectors(name, df, column_name):\n\t\t\"\"\"\n\t\t@info If data is categorical, for each category of choropleth data, create a colour selector ui element.\n\t\tElse if data is numerical, create a colour scheme selector\n\t\t@param filepath(str): used to uniqeuly identify ui elements\n\t\t@param df(pandas df): dataframe containing the value column\n\t\t@param column_name(str): the column with choropleth values\n\t\t\"\"\"\n\t\ttry:\n\t\t\t# remove old colour dropdowns\n\t\t\tui.remove_ui(selector=f\"#{name}_colour_dropdowns\")\n\t\texcept Exception as e:\n\t\t\tprint(f\"Error removing previous colour selectors:\\n{e}\")\n\n\t\t# get all colors\n\t\tcolor_keys = list(Colors)\n\t\tcolor_index = 0\n\t\t\n\t\t# get unique values in value column\n\t\tvalues = df[column_name].unique()\n\t\t# are values numerical or categorical?\n\t\tdata_type = GetChoroplethDataType(values)\n\n\t\t# user can select a colour for each category\n\t\tif data_type == \"categorical\":\n\t\t\tall_color_select = []\n\t\t\tfor category in values:\n\t\t\t\t# remove invalid characters for id name\n\t\t\t\tcategory_clean = re.sub(r\"\\s+\", \"\", str(category))\n\t\t\t\tcategory_clean = re.sub(f\"[^a-zA-Z0-9]\", \"_\", category)\n\t\t\t\tcolor_select = ui.input_select(id=f\"{name}Select{category_clean}\", label=f\"{category}\", choices=Colors, multiple=False, selectize=True, selected=color_keys[color_index])\n\t\t\t\tall_color_select.append(color_select)\n\t\t\t\tif color_index < (len(color_keys) - 1):\n\t\t\t\t\tcolor_index += 1\n\n\t\t\taccordion = ui.accordion(\n\t\t\t\tui.accordion_panel(\n\t\t\t\t\tf\"{name} Colors\",\n\t\t\t\t\t*all_color_select,\n\t\t\t\t), \n\t\t\t\tid=f\"{name}_colour_dropdowns\"\n\t\t\t)\n\n\t\t# user can select colours for a linear scheme\n\t\telse:\n\t\t\taccordion = ui.accordion(\n\t\t\t\tui.accordion_panel(\n\t\t\t\t\tf\"{name} Colors\",\n\t\t\t\t\tui.input_select(id=f\"{name}ColorSelect\", label=None, choices=Colors, multiple=True, selectize=True, selected=list(Colors)[0:3]),\n\t\t\t\t), \n\t\t\t\tid=f\"{name}_colour_dropdowns\"\n\t\t\t)\n\n\t\tui.insert_ui(\n\t\t\taccordion,\n\t\t\tselector=\"#ChoroplethSettings\",\n\t\t\twhere=\"beforeEnd\",\n\t\t)\n\n\n\t@reactive.effect\n\t@reactive.event(input.Example, input.Reset, new_load_flag)\n\tasync def UpdateDataChoropleth():\n\t\t\"\"\"\n\t\t@info Update data when the choropleth data file is selected or modified.\n\t\t\"\"\"\n\t\tp = ui.Progress()\n\t\ttry:\n\t\t\tDataChoropleth.set((await DataCache.Load(\n\t\t\t\tinput, \n\t\t\t\tp=p,\n\t\t\t\tinput_switch=\"Example\",\n\t\t\t\texample=\"Example\",\n\t\t\t\texample_file = input.Example(),\n\t\t\t)))\n\t\t\tValid.set(False)\n\n\t\t\tdata = DataChoropleth()  # dict of df\n\t\t\t\n\t\t\tfor filepath in data:\n\t\t\t\t# make Key Column and Value Column ui elements\n\t\t\t\tdf = data[filepath]\n\t\t\t\tname = GetNameFromPath(filepath)\n\t\t\t\t# get options for key and value column names\n\t\t\t\tcolumns = df.columns\n\t\t\t\tkey = Filter(columns, ColumnType.Name, id=None)\n\t\t\t\tval = Filter(columns, ColumnType.Value, id=None, all=True)\n\t\t\t\tif val:\n\t\t\t\t\tchoice = 0\n\t\t\t\t\twhile choice < len(val) and val[choice] == key:\n\t\t\t\t\t\tchoice += 1\n\t\t\t\t\n\t\t\t\tawait MakeColumnSelectors(name, key, val, choice)\n\n\t\t\t\t# make colour selectors for each category in val column\n\t\t\t\tawait MakeColorSelectors(name, df, val[choice])\n\n\t\t\tDataCache.Invalidate(File(input))\n\t\texcept Exception as e:\n\t\t\tprint(f\"choropleth error: {e}\")\n\t\t\tp.close()\n\t\t\tError(\"File could not be loaded!\\nChoropleth data can be uploaded as a .csv, .tsv, .txt, .xslx, .dat, .tab, or .odf file.\")\n\t\t\treturn\n\n\n\t@reactive.effect\n\t@reactive.event(input.JSONSelection)\n\tasync def UpdateGeoJSON():\n\t\t\"\"\"\n\t\tUpdate data when the choropleth GeoJSON file is selected or modified.\n\t\t\"\"\"\n\t\tJSON.set(await DataCache.Load(\n\t\t\tinput,\n\t\t\tsource_file=None,\n\t\t\texample_file=input.JSONSelection(),\n\t\t\tsource=URL,\n\t\t\tinput_switch=\"Provided\",\n\t\t\texample=\"Provided\",\n\t\t\tdefault=None,\n\t\t\tp=ui.Progress(),\n\t\t\tp_name=\"GeoJSON\"\n\t\t))\n\t\tfull_geojson = JSON()\n\t\tfilepath = next(iter(full_geojson))\n\t\tgeojson = full_geojson[filepath]\n\n\t\tif geojson is None: return\n\t\tproperties = list(geojson['features'][0]['properties'].keys())\n\t\t# update config.KeyProperty()\n\t\tFilter(properties, ColumnType.NameGeoJSON, id=\"KeyProperty\")\n\n\n\tasync def MakeSettingsForLayers(col_options:dict):\n\t\t\"\"\"\n\t\t@info When coordinate files are uploaded, make a settings dropdown for each file.\n\t\t\"\"\"\n\t\tif input.CoordinateSelection():\n\t\t\ttry:\n\t\t\t\t# remove old layer settings dropdowns\n\t\t\t\tui.remove_ui(selector=\"#dynamic_accordion\")\n\t\t\texcept Exception as e:\n\t\t\t\tprint(f\"Error removing previous file settings:\\n{e}\")\n\t\t\t\n\t\t\tsettings_dropdowns = []\n\t\t\tfor file in input.CoordinateSelection():\n\t\t\t\t#filename = file[\"name\"]\n\t\t\t\tname = file.split(\".\")[0]\n\t\t\t\tdropdown = ui.accordion_panel(\n\t\t\t\t\tf\"{file}\", \n\t\t\t\t\t# enable/disable layer\n\t\t\t\t\tui.input_checkbox_group(id=f\"Disable{name}\", inline=False, label=None, choices=[\"Disable Layer\"], selected=None),\n\t\t\t\t\t\n\t\t\t\t\t#config.TimeColumn.UI(ui.input_select, id=f\"TimeColumn{name}\", label=\"Time Column\", choices=col_options[f\"TimeColumn{name}\"], multiple=False, tooltip=\"Optional: Specify a time column to plot data over time. If an explicit time column is specified, data can be visualized temporally with a media-player-like interface (play, pause, rewind, and frame speed options). If 'None' is selected, the heatmap will be static.\"),\n\t\t\t\t\tconfig.ValueColumnCoord.UI(ui.input_select, id=f\"ValueColumnCoord{name}\", label=\"Value Column\", choices=[col_options[f\"ValueColumnCoord{name}\"], \"Uniform\"], selected=\"Uniform\", multiple=False, tooltip=\"If a column from the input data is specified, values from that column will be associated with each latitude, longitude point, and the point will be colored based on its value. If 'Uniform' is selected, data points will be assigned a uniform value and colored uniformly on the map.\"),\n\t\t\t\t\t# Colour data points by density, instead of assigned values. Uses kernel density estimation\n\t\t\t\t\tui.panel_conditional(\n\t\t\t\t\t\tf\"input.ValueColumnCoord{name} !== 'Uniform'\",\n\t\t\t\t\t\tui.input_checkbox_group(id=f\"KDE{name}\", inline=False, label=None, choices=[\"Color by Density\"], selected=None),\n\t\t\t\t\t),\n\t\t\t\t\t# select colours\n\t\t\t\t\tui.panel_conditional(\n\t\t\t\t\t\tf\"input.RenderMode{name} === 'Vector'\",\n\t\t\t\t\t\tui.input_select(id=f\"CustomColors{name}\", label=\"Colors\", choices=Colors, multiple=True, selectize=True, selected=[\"#8000ff\",\"#ff0000\",\"#ff9900\",\"#fff200\",\"#00ff80\",\"#00bfff\"]),\n\t\t\t\t\t),\n\t\t\t\t\t# point radius\n\t\t\t\t\tconfig.Radius.UI(ui.input_numeric, id=f\"Radius{name}\", label=\"Data Point Size\", min=5, tooltip=\"Specify how large each data point should be on the map.\"),\n\t\t\t\t\t# opacity\n\t\t\t\t\tconfig.OpacityCoord.UI(ui.input_slider, id=f\"OpacityCoord{name}\", label=\"Opacity\", min=0.0, max=1.0, step=0.1, tooltip=\"Specify the opacity of the heatmap. 1.0 indicates full opacity, while lower values make the background map more visible.\"),\n\t\t\t\t\t# raster/vector\n\t\t\t\t\tconfig.RenderMode.UI(ui.input_select, id=f\"RenderMode{name}\", label=\"Render Mode\", choices=[\"Raster\", \"Vector\"], tooltip=\"Display data as discrete vector points, or a smooth raster shape (vector does not apply to temporal heatmaps). The intensity of raster points scales when the map is zoomed in or out. Vector points maintain a constant intensity regardless of zoom, but are more computationally expensive.\"),\n\t\t\t\t\t# if vector - shape\n\t\t\t\t\t# TODO: fix!!!\n\t\t\t\t\tui.panel_conditional(\n\t\t\t\t\t\tf\"input.RenderMode{name} === 'Vector'\",\n\t\t\t\t\t\tconfig.RenderShape.UI(ui.input_select, id=f\"RenderShape{name}\", label=\"Vector Shape\", choices=[\"Circle\", \"Rectangle\"], tooltip=\"Specify the shape of vector points. Rectangular points are useful for contiguous data (like temperature or rainfall), while circular points are useful for discrete data (like disease cases or wildlife sightings).\"),\n\t\t\t\t\t),\n\t\t\t\t\t# if raster - blurring\n\t\t\t\t\tui.panel_conditional(\n\t\t\t\t\t\tf\"input.RenderMode{name} === 'Raster'\",\n\t\t\t\t\t\tconfig.Blur.UI(ui.input_slider, id=f\"Blur{name}\", label=\"Blurring\", min=1, max=30, step=1, tooltip=\"Specify how much neighbouring points bleed into one another. Higher values make the heatmap appear more homogeneous, while lower values emphasize individual points. This applies to raster heatmaps only.\"),\n\t\t\t\t\t),\n\t\t\t\t\t# ROI\n\t\t\t\t\tui.HTML(\"<b>Range of Interest</b>\"),\n\t\t\t\t\tconfig.ROICoord.UI(ui.input_checkbox, make_inline=False, id=f\"ROICoord{name}\", label=\"Enable Range of Interest\", tooltip=\"Define a minimum and maximum bound (inclusive) for data points. Select 'Remove' to ignore all data points outside of the range. Select 'Round' to round data points outside of the range to the maximum or minimum value. This setting is not applicable if 'Uniform' values are used.\"),\n\t\t\t\t\tconfig.ROI_ModeCoord.UI(ui.input_radio_buttons, make_inline=False, id=f\"ROI_ModeCoord{name}\", label=None, choices=[\"Remove\", \"Round\"], inline=True, tooltip=\"Remove data points outside the range of interest, or round them to the maximum or minimum value\"),\n\t\t\t\t\tui.layout_columns(\n\t\t\t\t\t\tconfig.MinCoord.UI(ui.input_numeric,make_inline=False, id=f\"Min{name}\", label=None, min=0, tooltip=\"Minimum displayed value in range of interest (inclusive).\"),\n\t\t\t\t\t\tconfig.MaxCoord.UI(ui.input_numeric, make_inline=False, id=f\"Max{name}\", label=None, min=0, tooltip=\"Maximum displayed value in range of interest (inclusive).\"),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\tsettings_dropdowns.append(dropdown)\n\n\t\t\taccordion = ui.accordion(*settings_dropdowns, id=\"dynamic_accordion\")\n\t\t\tui.insert_ui(\n\t\t\t\taccordion,\n\t\t\t\tselector=\"#ChoroplethSettings\",\n\t\t\t\twhere=\"afterEnd\",\n\t\t\t)\n\n\n\t@reactive.effect\n\t@reactive.event(input.CoordinateSelection)\n\tasync def UpdateCoordinateData():\n\t\t\"\"\"\n\t\tUpdate data when the coordinate data files are selected or modified.\n\t\t\"\"\"\n\t\tp = ui.Progress()\n\n\t\tif input.CoordinateSelection():\n\t\t\tcol_options = {}\n\t\t\ttry:\n\t\t\t\tDataCoordinate.set((await DataCache.Load(\n\t\t\t\t\tinput, \n\t\t\t\t\tsource_file=None,\n\t\t\t\t\texample_file=input.CoordinateSelection(),\n\t\t\t\t\tinput_switch=\"Example\",\n\t\t\t\t\texample=\"Example\",\n\t\t\t\t\tp=p,\n\t\t\t\t\tp_name=\"coordinate data\"\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t\tValid.set(False)  # list of df?\n\t\t\t\tdata = DataCoordinate()\n\t\t\t\tpath_dict = {}\n\t\t\t\tfor filepath in data:\n\t\t\t\t\t# TODO: use pathlib\n\t\t\t\t\tfilename = filepath.split(\"/\")[-1]\n\t\t\t\t\tpath_dict[filename] = filepath\n\n\t\t\t\tfor file in input.CoordinateSelection():\n\t\t\t\t\t# data[datapath]\n\t\t\t\t\tmapped_filepath = path_dict[file]\n\t\t\t\t\tfile_df = data[mapped_filepath]\n\n\t\t\t\t\tname = file.split(\".\")[0]\n\t\t\t\t\t# get columns per file\n\t\t\t\t\t# filter columns to get time and value dropdown options\n\t\t\t\t\tcolumns = file_df.columns\n\t\t\t\t\ttime = Filter(columns, ColumnType.Time, good=[\"None\"], all=True)\n\t\t\t\t\tval = Filter(columns, ColumnType.Value, good=[\"Uniform\"])\n\n\t\t\t\t\t# make UI elements\n\t\t\t\t\tcol_options[f\"TimeColumn{name}\"] = time\n\t\t\t\t\tcol_options[f\"ValueColumnCoord{name}\"] = val\n\t\t\t\t\n\t\t\t\tawait MakeSettingsForLayers(col_options)\n\n\t\t\t\tDataCache.Invalidate(File(input))\n\n\t\t\texcept Exception as e:\n\t\t\t\tprint(f\"coordinate error: {e}\")\n\t\t\t\t#p.close()\n\t\t\t\tError(ui.HTML(\"File could not be loaded!\\nCoordinate data can be uploaded as a .csv, .tsv, .txt, .xslx, .dat, .tab, or .odf file.\\n\"), e)\n\t\t\t\treturn\n\n\n\tdef GetDataChoropleth(): return Table.data_view() if Valid() else DataChoropleth()\n\n\t# TODO: add table for geocoordinate file(s)\n\tdef GetDataCoordinate(): \n\t\treturn DataCoordinate()  # dict of {datapath: df}\n\n\n\tdef GetChoroplethDataType(data):\n\t\t\"\"\"\n\t\t@brief Determine if data is numerical or categorical\n\t\t@param categories(numpy.ndarray): a list of unique values\n\t\tReturns: str indicating \"numerical\" or \"categorical\"\n\t\t\"\"\"\n\t\tdata_type = \"numerical\"\n\t\tfor item in data:\n\t\t\ttry:\n\t\t\t\titem = float(item)\n\t\t\texcept:\n\t\t\t\tdata_type = \"categorical\"\n\t\t\t\treturn data_type\n\t\treturn data_type \n\n\n\tdef LoadChoropleth(df, map, geojson, k_col, v_col, k_prop, name, p):\n\t\t\"\"\"\n\t\t@brief Applies a Choropleth to a Folium Map\n\t\t@param df: The DataFrame that contains information to plot\n\t\t@param map: The Folium map\n\t\t@param geojson: The geojson that contains territory info\n\t\t@param k_col: The name of the column within df that contains names\n\t\t@param v_col: the name of the column within df that contains the values to plot.\n\t\t@param k_prop: \n\t\t@param name(str): name of the file that data was pulled from\n\t\t\"\"\"\n\t\t# check if layer is disabled\n\t\tdisable_name = f\"Disable{name}\"\n\t\tdisable = getattr(input, disable_name)()\n\t\tif disable:\n\t\t\treturn\n\n\t\t# turn geojson dict into a df\n\t\tgeojson_df = GeoDataFrame.from_features(geojson, crs=\"EPSG:4326\")\n\t\t# merge with data df based on k_prop and k_col\n\t\tmerged = geojson_df.merge(df, how=\"left\", left_on=k_prop, right_on=k_col)\n\n\t\topacity = config.Opacity()\n\t\t# opacity_name = f\"OpacityChoro{name}\"\n\t\t# opacity = getattr(input, opacity_name)()\n\t\t\n\t\tdf_dict = df.set_index(k_col)[v_col]\n\t\tdf_dict = df_dict.to_dict()\n\n\t\t# add a popup that appears on click\n\t\tpopup = GeoJsonPopup(\n\t\t\tfields=[k_prop, v_col],\n\t\t\taliases=[\"\",\"\"],\n\t\t\tlocalize=True,\n\t\t\tlabels=True,\n\t\t)\n\n\t\tvalues = df[v_col].unique()\n\t\tdata_type = GetChoroplethDataType(values)\n\t\t\n\t\t# if data is numerical, make continuous colormap\n\t\tif data_type == \"numerical\":\n\t\t\tvmin = min(values)\n\t\t\tvmax = max(values)\n\t\t\tselected_colors_num_ui = f\"{name}ColorSelect\"\n\t\t\tselected_colors_num = getattr(input, selected_colors_num_ui)()\n\t\t\tif len(selected_colors_num) < 2:\n\t\t\t\tselected_colors_num += selected_colors_num\n\t\t\tcolormap = LinearColormap(selected_colors_num, vmin=vmin, vmax=vmax)\n\t\t\tGeoJson(\n\t\t\t\tmerged,\n\t\t\t\tstyle_function=lambda x:\n\t\t\t\t{\n\t\t\t\t\t\"fillColor\": colormap(df_dict[x['properties']['name']]) if x['properties']['name'] in df_dict else \"transparent\",\n\t\t\t\t\t\"color\": \"black\",\n\t\t\t\t\t\"weight\": 0.5,\n\t\t\t\t\t\"fillOpacity\": opacity,\n\t\t\t\t},\n\t\t\t\t#tooltip=tooltip,\n\t\t\t\tpopup=popup,\n\t\t\t).add_to(map)\n\t\t\n\t\t# if data is categorical, make categorical colormap\n\t\telse:\n\t\t\tcolors = []\n\t\t\tindices = []\n\t\t\tindex = 0\n\t\t\tcategory_to_color = {}\n\n\t\t\t# if categorical data, map categories to indices\n\t\t\tfor category in values:\n\t\t\t\tcategory_name = re.sub(r\"\\s+\", \"\", str(category))\n\t\t\t\tcategory_name = re.sub(f\"[^a-zA-Z0-9]\", \"_\", category)\n\t\t\t\tselected_color_ui = f\"{name}Select{category_name}\"\n\t\t\t\tselected_color = getattr(input, selected_color_ui)()\n\n\t\t\t\tcolors.append(selected_color)\n\t\t\t\tcategory_to_color[category] = selected_color\n\t\t\t\tindices.append(index)\n\t\t\t\tindex += 1\n\n\t\t\tGeoJson(\n\t\t\t\tmerged,\n\t\t\t\tstyle_function=lambda x:\n\t\t\t\t{\n\t\t\t\t\t\"fillColor\": category_to_color[(df_dict[x['properties']['name']])] if x['properties']['name'] in df_dict else \"transparent\",\n\t\t\t\t\t\"color\": \"black\",\n\t\t\t\t\t\"weight\": 0.5,\n\t\t\t\t\t\"fillOpacity\": opacity,\n\t\t\t\t},\n\t\t\t\t#tooltip=tooltip,\n\t\t\t\tpopup=popup,\n\t\t\t).add_to(map)\n\n\n\tdef GenerateCoordinateMap(df, map, name, val_col, lat_col, lon_col):\n\t\t\"\"\"\n\t\t@brief Generate a coordinate heatmap\n\t\t@param df A pandas DataFrame containing the data to map\n\t\t@param map A folium map to add data to\n\t\t@param name The name of file that this data is from (just used to identify the correct settings ui elements)\n\t\t@param val_col\n\t\t@param lat_col\n\t\t@param lon_col\n\t\t\"\"\"\n\t\tdisable_name = f\"Disable{name}\"\n\t\tdisable = getattr(input, disable_name)()\n\t\topacity_name = f\"OpacityCoord{name}\"\n\t\topacity = getattr(input, opacity_name)()\n\t\tradius_name = f\"Radius{name}\"\n\t\tradius = getattr(input, radius_name)()\n\t\tblur_name = f\"Blur{name}\"\n\t\tblur = getattr(input, blur_name)()\n\t\trender_name = f\"RenderMode{name}\"\n\t\trender = getattr(input, render_name)()\n\t\tkde_config_name = f\"KDE{name}\"\n\t\tkde_config = getattr(input, kde_config_name)()\n\t\tvector_shape_name = f\"RenderShape{name}\"\n\t\tvector_shape = getattr(input, vector_shape_name)()\n\n\t\tcustom_colors_name = f\"CustomColors{name}\"\n\t\tcustom_colors = getattr(input, custom_colors_name)()\n\t\tif len(custom_colors) == 0:\n\t\t\tError(\"Error: Please specify at least one color.\")\n\t\t\treturn \n\t\telif len(custom_colors) < 2:\n\t\t\tcustom_colors = custom_colors + custom_colors\n\n\t\tlatitude = df[lat_col]\n\t\tlongitude = df[lon_col]\n\t\tvalues = df[val_col]\n\n\t\tif disable:\n\t\t\treturn\n\t\t\n\t\t# Calculate kernel density estimation (https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html)\n\t\tif \"Color by Density\" in kde_config:\n\t\t\tstack = vstack([longitude, latitude])  # stack arrays vertically\n\t\t\tkde = gaussian_kde(stack)  # estimate PDF (probability density function)\n\t\t\tdensity = kde(stack)\n\t\t\tdf[val_col] = values + density * 0.1\n\t\t\n\t\t# Define data point style\n\t\tif render == \"Raster\":\n\t\t\tFoliumHeatMap(list(zip(df[lat_col], df[lon_col], df[val_col])),\n            min_opacity=opacity,\n            max_zoom=0,\n            radius=radius,\n            blur=blur).add_to(map)\n\t\telif render == \"Vector\":\n            # Define a linear colormap\n\t\t\tcolormap = LinearColormap(\n\t\t\t\tcolors=custom_colors,\n\t\t\t\tvmin=df[val_col].min(),\n\t\t\t\tvmax=df[val_col].max()\n\t\t\t)\n\t\t\t# add a CircleMarker for each data point\n\t\t\tfor index, row in df.iterrows():\n\t\t\t\tvalue = row[val_col]\n\t\t\t\tcolor = colormap(value)\n\n\t\t\t\tif vector_shape == \"Circle\":\n\t\t\t\t\tCircle(\n\t\t\t\t\t\tlocation=[row[lat_col], row[lon_col]],\n\t\t\t\t\t\tradius=radius * 10,\n\t\t\t\t\t\tcolor=color,\n\t\t\t\t\t\tfill=True,\n\t\t\t\t\t\topacity=opacity,\n\t\t\t\t\t\tfill_opacity=opacity,\n\t\t\t\t\t\tstroke=False\n\t\t\t\t\t).add_to(map)\n\t\t\t\telse:\n\t\t\t\t\tlat, lon = row[lat_col], row[lon_col]\n\t\t\t\t\trect_radius = radius / 10000\n\t\t\t\t\tRectangle(\n\t\t\t\t\t\tbounds=[[lat - rect_radius, lon - rect_radius], [lat + rect_radius, lon + rect_radius]],\n\t\t\t\t\t\tcolor=color,\n\t\t\t\t\t\tfill=True,\n\t\t\t\t\t\topacity=opacity,\n\t\t\t\t\t\tfill_opacity=opacity,\n\t\t\t\t\t\tstroke=False\n\t\t\t\t\t).add_to(map)\n\t\tmap.fit_bounds(map.get_bounds())\n\n\n\t@output\n\t@render.data_frame\n\tdef Table(): \n\t\t#TODO: modify for multiple choropleths! Currently just displays first in list\n\t\tdata = DataChoropleth()\n\t\tfilepath = next(iter(data))\n\t\tdf = data[filepath]\n\t\tif df is None or df.empty:\n\t\t\treturn DataFrame({\"Note\": [\"No data to display! Please upload your data or select an example data set in the sidebar.\"]})\n\t\ttry:\n\t\t\tgrid = render.DataGrid(df, editable=True)\n\t\t\tValid.set(True)\n\t\t\treturn grid\n\t\texcept:\n\t\t\treturn DataFrame({'Note': [ui.HTML('Could not render data! <br><br>Please make sure the names in your dataset match the names in a corresponding GeoJSON. Your input data should also have a column of values, and optionally, time. <br><br>See more formatting info <a href=\"https://github.com/WishartLab/heatmapper2/wiki/Format#geomap:~:text=work%20with%20it.-,Geomap,-Geomap%20has%20two\"; target=\"_blank\"; rel=\u201dnoopener noreferrer\u201d>here</a>.')]})\n\n\n\t@Table.set_patch_fn\n\tdef UpdateTable(*, patch: render.CellPatch) -> render.CellValue:\n\t\tif config.Type() == \"Integer\": value = int(patch[\"value\"])\n\t\telif config.Type() == \"Float\": value = float(patch[\"value\"])\n\t\telse: value = patch[\"value\"]\n\t\tDataCache.Invalidate(File(input))\n\t\treturn value\n\t\n\t# Info text in welcome tab\n\t@render.ui\n\tdef Welcome():\n\t\treturn ui.HTML(\"\"\"\n\t\t\t<h1>Maps</h1>\n\t\t\tSOIL-HUB Maps display values based on geographical boundaries (such as country, state, or province), with coordinate points displayed on top. Select a GeoJSON and choropleth data in the sidebar to get started. Select optional coordinate points to display on top. <br>Navigate to the 'Heatmap' tab to see the heatmap, 'Table' to look at the choropleth data, or 'GeoJSON' to see the geographical boundaries available in the currently selected GeoJSON file.\n\t\t\t\n\t\t\t<br><br>\n\t\t\t<img src=\"https://github.com/WishartLab/heatmapper2/wiki/assets/Geomap.png\" alt=\"Geomap\"; style=\"max-width:500px;\">\n\t\t\t<br>  \n \n\t\t\t<br><h3>Troubleshooting</h3>  \n\t\t\tRemember to select a GeoJSON with boundaries that match the names in your data. <br>Navigate to the 'GeoJSON' tab to see available boundaries in the GeoJSON file. Navigate to the 'Table' tab to see if your rows match these boundaries.\n\t\t\n\t\t\t<br>Click on the '?' icon beside sidebar options to read more about them.\n\t\t\"\"\")\n\n\n\tdef GenerateHeatmap():\n\t\twith ui.Progress() as p:\n\n\t\t\tp.inc(message=\"Loading input...\")\n\t\t\t#df_choropleth = GetDataChoropleth()\n\t\t\tdf_choropleth = DataChoropleth()\n\t\t\tdf_coordinates = GetDataCoordinate()\n\n\t\t\tif df_choropleth is None and df_coordinates is None:\n\t\t\t\tprint(\"No Choropleth/Coordinate dataframes :(\")\n\t\t\t\treturn ui.HTML(\"No data to display! Please upload your data or select an example data set in the sidebar.\")\n\t\t\t\n\t\t\t###### set up background map ######\n\t\t\tp.inc(message=\"Loading GeoJSON...\")\n\t\t\ttry:\n\t\t\t\t# get available GeoJSON property names (e.g. name, id,...)\n\t\t\t\tgeojson_dict = JSON()\n\t\t\t\tfilepath = next(iter(geojson_dict))\n\t\t\t\tgeojson = geojson_dict[filepath]\n\t\t\t\tproperties = list(geojson['features'][0]['properties'].keys()) \n\t\t\texcept Exception:\n\t\t\t\treturn ui.HTML('Make sure a GeoJSON is selected in the sidebar, <br>or upload your own following the <a href=\"https://geojson.org/\"; target=\"_blank\"; rel=\u201dnoopener noreferrer\u201d>GeoJSON format</a>.')\n\t\t\t\n\t\t\tmap_type = config.MapType()  # background map: either CartoDB or OSM\n\t\t\tif map_type == \"Esri World Imagery\":\n\t\t\t\tmap_type = \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n\t\t\t\tattribution = ('Powered by <a href=\"https://www.esri.com\">Esri</a>. Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community')\n\t\t\telif map_type == \"OpenStreetMap\":\n\t\t\t\tattribution = ('&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors')\n\t\t\telif map_type == \"CartoDB Positron\":\n\t\t\t\tattribution = ('&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> '\n\t\t\t\t   'contributors, &copy; <a href=\"https://carto.com/attribution\">CARTO</a>')\n\n\t\t\t# Give a placeholder map if nothing is selected, which should never really be the case.\n\t\t\tif df_choropleth is None or geojson is None: return FoliumMap((53.5213, -113.5213), tiles=map_type, attr=attribution, zoom_start=15)\n\n\t\t\tmap = FoliumMap(tiles=map_type, attr=attribution, zoom_control=\"topleft\", zoom_start=2)\n\n\t\t\t###### create choropleths ######\n\t\t\tif df_choropleth is not None:\n\t\t\t\tp.inc(message=\"Formatting choropleth...\")\n\t\t\t\tk_prop = config.KeyProperty()\n\t\t\t\t\n\t\t\t\t# df_choropleth is dict of choropleth dfs indexed by filepath, parse each one\n\t\t\t\tfor df_filepath in df_choropleth:\n\t\t\t\t\tname_choro = GetNameFromPath(df_filepath)\n\t\t\t\t\tdf_choro = df_choropleth[df_filepath]\n\t\t\t\t\t# HERE iiiiiiiiiiii\n\t\t\t\t\tv_col_name = f\"ValueColumn{name_choro}\"\n\t\t\t\t\tv_col = getattr(input, v_col_name)()\n\t\t\t\t\tk_col_name = f\"KeyColumn{name_choro}\"\n\t\t\t\t\tk_col = getattr(input, k_col_name)()\n\t\t\t\t\tif k_col not in df_choro or v_col not in df_choro or k_prop not in properties: \n\t\t\t\t\t\treturn ui.HTML(\"Data could not be displayed. <br>Please upload a Table file and a GeoJSON, or select an example data set in the sidebar. <br><br><i>Uploaded Table files should include: <br>a Key column (e.g. 'name', 'continent', 'country', 'location') <br>and a Value column (e.g. 'value', 'weight', 'intensity')</i>\")\n\n\t\t\t\t\tp.inc(message=\"Dropping Invalid Values...\")\n\t\t\t\t\tnames = []\n\t\t\t\t\tfor feature in geojson[\"features\"]:  # for each defined territory/polygon\n\t\t\t\t\t\tnames.append(feature[\"properties\"][k_prop])  # collect the specified property (e.g. name)\n\n\t\t\t\t\t# remove high and low values if \"range of interest\" is enabled\n\t\t\t\t\tto_drop = []\n\t\t\t\t\tfor index, key in zip(df_choro.index, df_choro[k_col]):\n\t\t\t\t\t\tif key not in names: to_drop.append(index)\n\n\t\t\t\t\tdf_choro = df_choro.drop(to_drop)\n\t\t\t\t\tif len(df_choro) == 0:\n\t\t\t\t\t\tError(\"No locations found\")\n\t\t\t\t\t\treturn ui.HTML(\"No locations were found. <br>Please ensure your data table contains a name column, whose values match a property in the GeoJSON.\")\n\n\t\t\t\t\t# Load the choropleth onto the map\n\t\t\t\t\tp.inc(message=\"Plotting...\")\n\t\t\t\t\tLoadChoropleth(df_choro, map, geojson, k_col, v_col, k_prop, name_choro, p)\n\n\t\t\t###### create coordinate layers ######\n\t\t\tif df_coordinates is not None:\n\t\t\t\tfor filepath in df_coordinates:\n\n\t\t\t\t\t# get filename so we can build ui element ids\n\t\t\t\t\tname = GetNameFromPath(filepath)\n\t\t\t\t\t# set up dataframe\n\t\t\t\t\tdf_coord = df_coordinates[filepath]\n\t\t\t\t\tdf_coord = df_coord.copy(deep=True)\n\t\t\t\t\t\n\t\t\t\t\tp.inc(message=\"Formatting...\")\n\t\t\t\t\tlon_col = Filter(df_coord.columns, ColumnType.Longitude)\n\t\t\t\t\tlat_col = Filter(df_coord.columns, ColumnType.Latitude)\n\t\t\t\t\tif lat_col is None or lon_col is None: \n\t\t\t\t\t\treturn ui.HTML('The heat map could not be rendered. <br><br>Please ensure your input data contains a latitude column (named \"latitude\" or \"lat\"), and a longitude column (named \"longitude\", \"long\", or \"lon\"). Column names are case-insensitive. <br>More information on formatting is available in the <a href=\"https://github.com/WishartLab/heatmapper2/wiki/Format#geocoordinate:~:text=the%20Table%20tab)-,Geocoordinate,-Geocoordinate%20takes%20a\"; target=\"_blank\"; rel=\u201dnoopener noreferrer;>Wiki</a>.')\n\t\t\t\t\tval_col_name = f\"ValueColumnCoord{name}\"\n\t\t\t\t\tval_col = getattr(input, val_col_name)()\n\t\t\t\t\t# colour all points uniformly\n\t\t\t\t\tif val_col == \"Uniform\":\n\t\t\t\t\t\tdf_coord[\"Default_Uniform_Values\"] = [1] * len(df_coord[lat_col])\n\t\t\t\t\t\tval_col = \"Default_Uniform_Values\"\n\n\t\t\t\t\t# drop invalid values if using range of interest\n\t\t\t\t\tp.inc(message=\"Dropping Invalid Values...\")\n\t\t\t\t\troi_name = f\"ROICoord{name}\"\n\t\t\t\t\troi = getattr(input, roi_name)()\n\t\t\t\t\troi_mode_name = f\"ROI_ModeCoord{name}\"\n\t\t\t\t\troi_mode = getattr(input, roi_mode_name)()\n\t\t\t\t\tmin_name = f\"Min{name}\"\n\t\t\t\t\tmin_val = getattr(input, min_name)()\n\t\t\t\t\tmax_name = f\"Max{name}\"\n\t\t\t\t\tmax_val = getattr(input, max_name)()\n\n\t\t\t\t\tif roi:\n\t\t\t\t\t\tto_drop = []\n\t\t\t\t\t\tlower, upper = min_val, max_val\n\t\t\t\t\t\tfor index, value in zip(df_coord.index, df_coord[val_col]):\n\t\t\t\t\t\t\tif value < lower or value > upper:\n\t\t\t\t\t\t\t\tif roi_mode == \"Remove\": to_drop.append(index)\n\t\t\t\t\t\t\t\telif roi_mode == \"Round\": df_coord.at[index, val_col] = upper if value > upper else lower\n\t\t\t\t\t\tdf_coord = df_coord.drop(to_drop)\n\t\t\t\t\t\tif len(df_coord) == 0:\n\t\t\t\t\t\t\tError(\"No locations to display! Check your Range of Interest and ensure the Value Column is properly set.\")\n\t\t\t\t\t\t\treturn ui.HTML(\"No locations to display! Check your Range of Interest and ensure the Value Column is properly set.\")\n\t\t\t\t\t\n\t\t\t\t\t# time_col_name = f\"TimeColumnCoord{name}\"\n\t\t\t\t\t# time_col = getattr(input, time_col_name)()\n\t\t\t\t\t# generate coordinate map and add to map\n\t\t\t\t\tp.inc(message=\"Plotting...\")\n\t\t\t\t\tGenerateCoordinateMap(df_coord, map, name, val_col, lat_col, lon_col)\n\n\t\t\tmap.fit_bounds(map.get_bounds())\n\t\t\treturn map\n\n\t@output\n\t@render.ui\n\tdef Heatmap(): return GenerateHeatmap()\n\n\n\t@output\n\t@render.ui\n\t@reactive.event(input.Update)\n\tdef HeatmapReactive(): return GenerateHeatmap()\n\n\n\t@output\n\t@render.data_frame\n\tdef GeoJSON():\n\t\tgeojson_dict = JSON()\n\t\tfilepath = next(iter(geojson_dict))\n\t\tgeojson = geojson_dict[filepath]\n\n\t\tif geojson is None:\n\t\t\treturn DataFrame({'Note':[ui.HTML('Hmmm, we could not render the GeoJSON table.<br><br>Make sure a GeoJSON is selected in the right hand sidebar, <br>or upload your own following the <a href=\"https://geojson.org/\"; target=\"_blank\"; rel=\u201dnoopener noreferrer\u201d>GeoJSON format</a>.')]})\n\t\ttry:\t\n\t\t\t# get selected key property (e.g. name) for each polygon/territory in GeoJSON\n\t\t\tnames = [feature['properties'][config.KeyProperty()] for feature in geojson['features']]\n\t\t\t# return a simple dataframe of the kye properties to display under the GeoJSON tab\n\t\t\treturn DataFrame({config.KeyProperty(): names})\n\t\texcept:\n\t\t\tError(\"Could not render the GeoJSON table!\")\n\t\t\treturn DataFrame({'Note':[ui.HTML('Hmmm, we could not render the GeoJSON table.<br><br>Make sure a GeoJSON is selected in the right hand sidebar, <br>or upload your own following the <a href=\"https://geojson.org/\"; target=\"_blank\"; rel=\u201dnoopener noreferrer\u201d>GeoJSON format</a>.')]})\n\n\n\t@reactive.effect\n\t@reactive.event(input.ExampleInfo)\n\tdef ExampleInfo():\n\t\t\"\"\"\n\t\tDisplay information text about each example file\n\t\t\"\"\"\n\t\tMsg(ui.HTML(InfoChoropleth[input.Example()]))\n\t\t\n\n\t@render.download(filename=lambda: f\"table{config.TableType()}\")\n\tdef DownloadTable(): \n\t\tdata = GetDataChoropleth()\n\t\t\n\t\t# return error if no data to download\n\t\tif data.empty:\n\t\t\tError(\"The downloaded table is empty! Please upload your data or select an example data set in the sidebar.\")\n\t\t\n\t\tfile_contents = data.to_string()\n\t\tyield file_contents\n\n\n\t@render.download(filename=\"heatmap.html\")\n\tdef DownloadHeatmap(): yield GenerateHeatmap().get_root().render()\n\n\napp_ui = ui.page_fluid(\n\n\tui.tags.style(\"\"\"\n\t\t.navbar {\n\t\t\tposition: fixed;  /* prevent navbar from scrolling */\n\t\t\ttop: 0;\n\t\t\theight: 10vh;\n\t\t\twidth: 100%;\n\t\t\tz-index: 1001;\n\t\t\toverflow-x: auto;\n        }\n\t\t.navbar-nav {\n\t\t\tflex-wrap: nowrap !important;\n\t\t}\n\t\t\t   \n\t\t.bslib-sidebar-layout {\n\t\t\tmargin-top: 10vh;  /* prevent content from being hidden under navbar */\n\t\t}\n\t\t.bslib-grid {\n\t\t\tdisplay: flex;\n\t\t\twidth: 100%;\n\t\t    justify-content: space-between;\n\t\t}\n\n\t\"\"\"),\n\n\tui.panel_title(title=None, window_title=\"Geomap\"),\n\tNavBar(),\n\n\tui.layout_sidebar(\n\t\t# left hand sidebar - Coordinate settings\n\t\tui.sidebar(\n\n\t\t\tui.accordion(\n\t\t\t\t# file selection for choropleth\n\t\t\t\tui.accordion_panel(\n\t\t\t\t\t\"Choropleth Files\",\n\t\t\t\t\tui.HTML(\"Select a GeoJSON file\"),\n\t\t\t\t\tui.input_select(id=\"JSONSelection\", label=None, choices=Mappings, multiple=False, selected=\"edmonton.geojson\"),\n\t\t\t\t\t\n\t\t\t\t\tui.HTML(\"Add choropleth data\"),\n\t\t\t\t\tInlineify(\n\t\t\t\t\t\tui.input_select, \n\t\t\t\t\t\tid=\"Example\", \n\t\t\t\t\t\tlabel=ui.input_action_link(id=\"ExampleInfo\", label=\"File Info\"), \n\t\t\t\t\t\tchoices={\n\t\t\t\t\t\t\t\"Backyard_Hens_and_Bees.csv\": \"Hens & Bees (Edmonton)\",\n\t\t\t\t\t\t\t\"FormerMunicipalities.csv\": \"Former Municipalities (Edmonton)\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\tmultiple=True,\n\t\t\t\t\t\tselected=\"Backyard_Hens_and_Bees.csv\",\n\t\t\t\t\t\tselectize=True,\n\t\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\t# file selection for latitude & longitude points\n\t\t\t\tui.accordion_panel(\n\t\t\t\t\t\"Coordinate Files\",\n\t\t\t\t\tui.input_select(\n\t\t\t\t\t\tid=\"CoordinateSelection\", \n\t\t\t\t\t\tlabel=None, \n\t\t\t\t\t\tchoices={\n\t\t\t\t\t\t\t\"gardens.csv\": \"Edmonton Community Gardens\",\n\t\t\t\t\t\t\t\"foodbanks.csv\": \"Edmonton Food Banks\",\n\t\t\t\t\t\t}, \n\t\t\t\t\t\tmultiple=True, \n\t\t\t\t\t\tselected=None,\n\t\t\t\t\t\tselectize=True,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t),\n\t\t\t\n\t\t\tTableOptions(config),\n\n\t\t\tui.panel_conditional(\n\t\t\t\t\"input.MainTab === 'HeatmapTab'\",\n\n\t\t\t\tUpdate(),\n\n\t\t\t\tui.accordion(\n\t\t\t\t\tui.accordion_panel(\n\t\t\t\t\t\t\"Choropleth Settings\",\n\t\t\t\t\t\tui.HTML(\"<b>Columns/Properties</b>\"),\n\t\t\t\t\t\t# config.KeyColumn.UI(ui.input_select, id=\"KeyColumn\", label=\"Name Column\", choices=[], tooltip=\"Specify a column in your data that contains location names. These location names must correspond to location names in the GeoJSON file. Click on the 'GeoJSON' tab in the main view area to see location names in the currently selected GeoJSON file.\"),\n\t\t\t\t\t\t# config.ValueColumn.UI(ui.input_select, id=\"ValueColumn\", label=\"Value Column\", choices=[], tooltip=\"Specify a column containing the data to plot.\"),\n\t\t\t\t\t\tconfig.KeyProperty.UI(ui.input_select, id=\"KeyProperty\", label=\"GeoJSON Property\", choices=[], tooltip=\"Select a property in the GeoJSON file that corresponds to the location names in your data. Click on the 'GeoJSON' tab in the main view area to see available properties in the currently selected GeoJSON file.\"),\n\t\t\t\t\t\t\n\t\t\t\t\t\tui.HTML(\"<b>Heatmap</b>\"),\n\t\t\t\t\t\tconfig.MapType.UI(ui.input_select, id=\"MapType\", label=\"Background Map\", choices={\"CartoDB Positron\": \"Simple Map\", \"OpenStreetMap\": \"Street Map\", \"Esri World Imagery\": \"Satellite\"}, tooltip=\"Specify the background map to plot your data on. CartoDB is a simpler map, while OSM is more highly annotated.\"),\n\t\t\t\t\t\tconfig.Opacity.UI(ui.input_slider, id=\"Opacity\", label=\"Choropleth Opacity\", min=0.0, max=1.0, step=0.1, tooltip=\"Specify the opacity of the heatmap. 1.0 indicates full opacity, while lower values make the background map more visible.\"),\n\t\t\t\t\t),\n\n\t\t\t\t\t# DO NOT CHANGE THIS ID - individual file settings panels are oriented based on this\n\t\t\t\t\tid=\"ChoroplethSettings\",\n\t\t\t\t),\n\t\t\t\tui.download_button(id=\"DownloadHeatmap\", label=\"Download HTML\"),\n\t\t\t),\t\n\t\t\tposition=\"left\",\n\t\t\tpadding=\"10px\",\n\t\t\tgap=\"20px\",\n\t\t\twidth=\"300px\",\n\t\t),\n\t\tMainTab(ui.nav_panel(\"GeoJSON\", ui.output_data_frame(\"GeoJSON\")), m_type=ui.output_ui),\n\t\theight=\"86vh\",\n\t\t\n\t)\n)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "config.py", "content": "#\n# Heatmapper \n# Geomap Configuration\n#\n# This file contains configuration for Geomap. \n\n\nfrom shared import Config, ConfigHandler\n\nconfig = ConfigHandler({\n    \n\t############# CHOROPLETH CONFIG #############\n\t# Temporal Heatmaps. True or False\n\t\"Temporal\": Config(value=False),\n\n\t# See expression's config for explanation of dynamic inputs.\n\t\"KeyColumn\": Config(),\n\t\"ValueColumn\": Config(),\n\t\"KeyProperty\": Config(),\n\n\t# \"CartoDB Positron\", \"OpenStreetMap\"\n\t\"MapType\": Config(selected=\"CartoDB Positron\"),\n\n\t# See shared.py for ColorMaps\n\t\"ColorMap\": Config(selected=\"Viridis\"),\n\n\t# Any floating value between 0.0 and 1.0\n\t\"Opacity\": Config(value=0.5),\n\n\t# Any number from 3-8\n\t\"Bins\": Config(value=5),\n\n\t# Allow toggling Range of Interest\n\t\"ROI\": Config(value=False),\n\n\t# \"Remove\" or \"Round\"\n\t\"ROI_Mode\": Config(selected=\"Remove\"),\n\n\t# Any number; the minimum/maximum bound for ROI\n\t\"Min\": Config(value=0),\n\t\"Max\": Config(value=0),\n\n\t# \"Integer\" \"Float\" \"String\"\n\t\"Type\": Config(selected=\"Integer\"),\n\n\t# No value, just toggle visibility.\n\t\"DownloadTable\": Config(),\n    \n\t# \".txt\" \".csv\" \".tsv\" \".xlsx\"\n    \"TableType\": Config(selected=\".txt\"),\n    \n\t############# COORDINATE CONFIG #############\n    # See expression's config for explanation of dynamic inputs.\n\t\"TimeColumn\": Config(),\n\t\"ValueColumnCoord\": Config(),\n\n\t\"RenderMode\": Config(selected=\"Raster\"),\n\t\"RenderShape\": Config(selected=\"Circle\"),\n    \n\t# Any floating value between 0.0 and 1.0\n\t\"OpacityCoord\": Config(value=0.7),\n    \n\t# Any numerical value from 5-100\n\t\"Radius\": Config(value=25),\n    \n\t# Any numerical value from 1-30\n\t\"Blur\": Config(value=15),\n    \n\t# Allow toggling Range of Interest\n\t\"ROICoord\": Config(value=False),\n\t# \"Remove\" or \"Round\"\n\t\"ROI_ModeCoord\": Config(selected=\"Remove\"),\n\t# Any number; the minimum/maximum bound for ROI\n\t\"MinCoord\": Config(value=0),\n\t\"MaxCoord\": Config(value=0),\n\n})", "type": "text"}, {"name": "geojson.py", "content": "# Generated from dictionary.sh\nMappings = { \"subpastures_wgs84.geojson\": \"SubPastures\", \"ecodistrict.geojson\": \"Ecodistricts\", \"calgary.geojson\": \"Calgary\", \"canada.geojson\": \"Canada\", \"edmonton.geojson\": \"Edmonton\", \"mississauga.geojson\": \"Mississauga\", \"montreal.geojson\": \"Montreal\", \"north-america.geojson\": \"North America\", \"peaks.geojson\": \"Peaks\", \"poland-parks.geojson\": \"Poland Parks\", \"quebec.geojson\": \"Quebec\", \"red-deer.geojson\": \"Red Deer\", \"saskatoon.geojson\": \"Saskatoon\", \"surrey.geojson\": \"Surrey\", \"toronto.geojson\": \"Toronto\", \"united-states-1810.geojson\": \"United States 1810\", \"united-states-big-cities.geojson\": \"United States Big Cities\", \"united-states-international-airports.geojson\": \"United States International Airports\", \"united-states-mlb-stadiums.geojson\": \"United States Mlb Stadiums\", \"united-states.geojson\": \"United States\", \"vancouver.geojson\": \"Vancouver\" }\n\n", "type": "text"}, {"name": "requirements.txt", "content": "folium==0.19.4\nopenpyxl==3.1.5\n", "type": "text"}, {"name": "shared.py", "content": "#\n# Heatmapper\n# Shared\n#\n# This file contains shared functionality between Heatmapper applications. It is not a standalone application.\n#\n\n\nfrom os.path import exists\nfrom copy import deepcopy\nfrom enum import Enum\nfrom io import BytesIO\nfrom json import loads\nfrom pathlib import Path\nfrom sys import modules\nfrom tempfile import NamedTemporaryFile\n\nfrom shiny import ui, reactive\nfrom shiny.types import FileInfo\nfrom pandas import DataFrame, read_csv, read_excel, read_table\n\nimport openpyxl\n\n# Used for fetching web resources\nURL = \"https://wishartlab.github.io/agmaps\"\nRaw = \"https://raw.githubusercontent.com/wishartlab/agmaps/main\"\n\n\n# Icon to display for tooltips\nTooltipIcon = ui.HTML(\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"12\" fill=\"currentColor\" class=\"bi bi-question-circle-fill mb-1\" viewBox=\"0 0 16 16\"><path d=\"M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.496 6.033h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286a.237.237 0 0 0 .241.247zm2.325 6.443c.61 0 1.029-.394 1.029-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94 0 .533.425.927 1.01.927z\"/></svg>'\n)\n\n\n# Detect the running environment\nif \"pyodide\" in modules:\n\tfrom pyodide.http import pyfetch\n\tPyodide = True\n\tasync def fetch(url):\n\t\tresponse = await pyfetch(url)\n\t\tif response.ok: return (await response.bytes())\n\t\telse:\n\t\t\tError(\"Could not download file\")\n\t\t\treturn None\nelse:\n\tfrom urllib.request import urlopen\n\tPyodide = False\n\tasync def fetch(url):\n\t\ttry: return urlopen(url).read()\n\t\texcept Exception:\n\t\t\tError(\"Could not download file!\")\n\t\t\treturn None\n\n# Shared Values\nColors = {\n\t\"#8000ff\": \"Purple\",\n\t\"#00bfff\": \"Blue\",\n\t\"#00ff80\": \"Green\",\n\t\"#fff200\": \"Yellow\",\n\t\"#ff9900\": \"Orange\",\n\t\"#ff0000\": \"Red\",\n\t\"#ff00aa\": \"Pink\",\n\t\"#7d7d7d\": \"Gray\",\n\t\"#ffffff\": \"White\",\n\t\"#00ffff\": \"Cyan\",\n\t\"#855944\": \"Brown\",\n\t\"#5e7832\": \"Olive\"\n}\n\n# color maps \nColorMaps = [\"Viridis\", \"Plasma\", \"Inferno\"]\n\nclass ColumnType(Enum): Time = 0; Name = 1; Value = 2; Longitude = 3; Latitude = 4; Free = 5; NameGeoJSON = 6\nColumns = {\n\tColumnType.Time: {\"time\", \"date\", \"year\"},\n\tColumnType.Name: {\"name\", \"orf\", \"uniqid\", \"face\", \"triangle\", \"iso_code\", \"continent\", \"country\", \"location\", \"territory\"},\n\tColumnType.Value: {\"value\", \"weight\", \"intensity\", \"amount\", \"level\", \"count\"},\n\tColumnType.Longitude: {\"longitude\", \"long\", \"lon\"},\n\tColumnType.Latitude: {\"latitude\", \"lat\"},\n\tColumnType.Free: {None},\n\tColumnType.NameGeoJSON: {\"name\", \"admin\", \"iso_a3\", \"iso_a2\", \"iso\"},\n\t}\n\n\ndef Filter(columns, ctype: ColumnType, good: list = [], id=None, all=False, remove_unknown=False):\n\t\"\"\"\n\t@brief Filters available column names based on what input we want\n\n\t@param columns: The columns of the DataFrame (Usually just df.columns)\n\t@param ctype: The type of column we're looking for (Look at the ColumnType Enum)\n\t@param good: A list of column names on top of those defined by the type to be included\n\t@param id: An element id to update with a new value.\n\t@param all: Return all matches columns\n\t@param remove_unknown: Whether we should remove unrecoxgnized values.\n\t\n\t@return: A list of column names to use.\n\n\t@info This purpose of this function is to try and remove irrelevant columns from user selection,\n\tbut returning everything if by filtering so we remove all the columns. In essence, it folds the case\n\tof all columns, and performs a set intersection on the required column type. This set is then returned\n\tto the case of the original columns, and then good and bad are applied (Therefore, they are case-sensitive)\n\tSince both good and bad are applied after the intersection, they don't need to be valid names (So long as)\n\tthe application can handle that exception. Look at Geocoordinate to see how it uses a \"None\" and \"Uniform\"\n\tvalue in the good list, despite these values both not a valid ValueColumn, and not existing in the data.\n\n\tThe logic for the UI updating can be confusing, but in essence we don't just want to return the good\n\tlist, because that means we removed all actual columns. If this happens, we return all the columns, and\n\tadd the good list onto the START (So its the default), that way users can choose a column if Heatmapper\n\tdoesn't like their column names.\n\t\"\"\"\n\t# Fold cases\n\tfolded = []\n\tfor column in columns:\n\t\ttry:\n\t\t\tfolded.append(column.lower())\n\t\texcept Exception:\n\t\t\tfolded.append(column)\n\toptions = set(folded)\n\tif ctype != ColumnType.Free: \n\t\toptions &= Columns[ctype]\n\n\tif remove_unknown:\n\t\tfor type in Columns:\n\t\t\tif type != ctype: \n\t\t\t\toptions -= Columns[type]\n\n\tindices = [folded.index(value) for value in options]; indices.sort()\n\treassembled = [columns[index] for index in indices] + good\n\n\tif id:\n\t\tif reassembled == good:\n\t\t\toptions = set(folded)\n\t\t\tfor type in Columns:\n\t\t\t\tif type != ctype: \n\t\t\t\t\toptions -= Columns[type]\n\t\t\tindices = [folded.index(value) for value in options]; indices.sort()\n\t\t\treassembled = good + [columns[index] for index in indices]\n\t\tui.update_select(\n\t\t\tid=id, \n\t\t\tchoices=reassembled,\n\t\t\t)\n\tif all: return reassembled\n\treturn reassembled[0] if reassembled and len(reassembled) > 0 else None\n\n\nclass Cache:\n\t\"\"\"\n\t@brief A class that encompasses fetching/storing web resources.\n\t\"\"\"\n\n\t@staticmethod\n\tdef HandleDataFrame(path, function, p=None):\n\t\t\"\"\"\n\t\t@brief Handle DataFrames\n\t\t@param path: \n\t\t@param function: The pandas function to use to read the file.\n\t\t@returns A DataFrame\n\t\t\"\"\"\n\n\t\t# Read the table once.\n\t\tif p: p.inc(message=\"Reading Table...\")\n\t\tdf = function(path.resolve()).fillna(0)\n\n\t\t# If the first column value is a float, we assume it's data, and not column names.\n\t\t# Re-read the DataFrame with generic column names instead\n\t\ttry:\n\t\t\tfloat(df.columns[0])\n\t\t\tif p: p.inc(message=\"Generating incidices...\")\n\t\t\tdf = function(path.resolve(), header=None, names=[f\"Column {i}\" for i in range(df.shape[1])])\n\t\texcept ValueError: pass\n\t\treturn df\n\n\n\t@staticmethod\n\tdef DefaultHandler(path, p=None):\n\t\t\"\"\"\n\t\t@brief The default handler. It can handle CSVs, Excel files, Tables, and all other files will simply be stored as strings of the file content\n\n\t\t@param path: Path to file\n\t\t@returns: An object.\n\t\t\"\"\"\n\t\tsuffix = path.suffix\n\t\tif suffix == \".geojson\": return loads(path.open().read())\n\t\tif suffix == \".csv\": return Cache.HandleDataFrame(path, read_csv, p)\n\t\telif suffix in {\".xlsx\", \".xls\", \".odf\"}: return Cache.HandleDataFrame(path, read_excel, p)\n\t\telif suffix in {\".txt\", \".dat\", \".tsv\", \".tab\"}: return Cache.HandleDataFrame(path, read_table, p)\n\t\telse: return open(path.resolve(), \"r\").read()\n\n\n\tasync def _local(self, url):\n\t\tif not exists(url): return None\n\t\treturn open(url, \"rb\").read()\n\n\n\tdef __init__(self, project, DataHandler = DefaultHandler):\n\t\t\"\"\"\n\t\t@brief Initialize an instance of the Cache object.\n\t\t@param project: The name of the project. This is used to fetch web resources.\n\t\t@param DataHandler:\tThe function that should be called to process files. It should \n\t\ttake a name, and a binary stream, and return a dictionary of DataFrames.\n\t\t\"\"\"\n\n\t\t# The primary is the unprocessed, fetched web resources\n\t\tself._primary = {}\n\n\t\t# The objects are anything that applications want to store\n\t\tself._objects = {}\n\n\t\t# The data handler for processing the binary files.\n\t\tself._handler = DataHandler\n\n\t\t# If we're in a Pyodide environment, we fetch resources from the web.\n\t\tif Pyodide:\n\t\t\tself._download = fetch\n\t\t\tself._source = f\"{Raw}/{project}/example_input/\"\n\n\t\t# Otherwise, we fetch locally.\n\t\telse:\n\t\t\tself._download = self._local\n\t\t\tself._source = \"../example_input/\"\n\n\n\tasync def Download(self, n, p=None):\n\t\t\"\"\"\n\t\t@brief Downloads any arbitrary URL and stores it in the cache\n\t\t@param n: The URL name\n\t\t@returns The handled data\n\n\t\t\"\"\"\n\t\tif n not in self._primary:\n\t\t\traw = await (fetch(n) if n.startswith(\"https://\") else self._download(n))\n\t\t\tif raw is None: return None\n\n\t\t\tpath = Path(n)\n\t\t\tif path.is_file():\n\t\t\t\tself._primary[n] = self._handler(path, p)\n\t\t\telse:\n\t\t\t\ttemp = NamedTemporaryFile(suffix=Path(n).suffix)\n\t\t\t\ttemp.write(raw)\n\t\t\t\ttemp.seek(0)\n\t\t\t\tself._primary[n] = self._handler(Path(temp.name), p)\n\t\ttry:\n\t\t\treturn deepcopy(self._primary[n])\n\t\texcept Exception:\n\t\t\treturn self._primary[n]\n\n\n\tasync def Load(self,\n\t\tinput,\n\t\tsource_file=None,\n\t\texample_file=None,\n\t\tsource=None,\n\t\tinput_switch=None,\n\t\tupload=\"Upload\",\n\t\texample=\"Example\",\n\t\tdefault=DataFrame(),\n\t\tp=None,\n\t\tp_name=\"file\",\n\t\twasm=True,\n\t\twasm_blacklist=tuple()\n\t\t):\n\n\t\t\"\"\"\n\t\t@brief Caches whatever the user has currently uploaded/selection, returning the identifier within the secondary cache.\n\t\t@param input: The Shiny input variable. Importantly, these must be defined:\n\t\t\tinput.File: The uploaded file\n\t\t\tinput.Example: The selected example file\n\t\t\tinput.SourceFile: Whether the user wants \"Upload\" or \"Example\"\n\t\t@param source_file: The input ID that should be used to fetch the file (Defaults to input.File() if None)\n\t\t@param example_file: The input ID that should be used to fetch the example (Defaults to input.Example() if None)\n\t\t@param input_switch: The input ID to check for Upload/Example/Other. The value is compared against \"Upload\" for user uploaded items, and defaults to fetching example_file otherwise. (Defaults to input.SourceFile())\n\t\t@param upload: The value of the input_switch such that we should fetch a source file from source_file\n\t\t@param example: The value of the input_switch such that we should fetch an example from example_file\n\t\t@param default:\tThe object that should be returned if files cannot be fetched. Ensures that Load will always return an object, avoiding the needing to check output. Defaults to a DataFrame. The object should be able to initialize without arguments.\n\t\t@param p: A progress bar to increment; optional.\n\t\t@param p_name: What we're fetching, to be displayed in the progress bar; optional\n\t\t@param wasm: Whether this fetch can run in WebAssembly\n\t\t@param wasm_blacklist: A tuple of file extensions that should not be fetched in WebAssembly.\n\t\t@returns The data if it exists, as either a single object or a dict of objects if multiple files were loaded; default if no file can be found; 0 if there's a WebAssembly violation\n\t\t\"\"\"\n\n\t\tif not wasm and Pyodide:\n\t\t\tif p: p.close()\n\t\t\treturn 0\n\n\t\t#if source_file is None: source_file = input.Example()\n\t\t#if example_file is None: example_file = input.Example()\n\t\tif source is None: source = self._source\n\t\t#if input_switch is None: input_switch = \"Example\"\n\n\t\t# Example files can be on disk or on a server depending on whether we're in a WASM environment.\n\t\tif input_switch == example:\n\t\t\tif p: p.inc(message=f\"Fetching {p_name}...\")\n\t\t\tfile: list[FileInfo] | None = example_file\n\t\t\tif file is None:\n\t\t\t\tif p: p.close()\n\t\t\t\treturn default\n\t\t\telif type(file) != list and type(file) != tuple:\n\t\t\t\tfile = [file]\n\t\t\t\n\t\t\tif p: p.inc(message=f\"Handling {p_name}\")\n\t\t\t# load example files from datapath\n\t\t\tall_n = []\n\t\t\tfor i in range(len(file)):\n\t\t\t\t#n = str(file[i][\"datapath\"])\n\t\t\t\tn = file[i]  # filename\n\t\t\t\tif n.endswith(wasm_blacklist) and Pyodide:\n\t\t\t\t\tcontinue\n\t\t\t\telif n.startswith(\"https://\"):\n\t\t\t\t\tn = n if Pyodide else str(source + n.split(\"/\")[-1])\n\t\t\t\telse:\n\t\t\t\t\tn = str(source + n)  # full file path\n\t\t\t\tall_n.append(n)\n\t\t\t\tif n not in self._primary: self._primary[n] = self._handler(Path(n), p)  # add actual data to primary (df or dict)\n\n\t\t\tif len(all_n) < 1:\n\t\t\t\tif p: p.close()\n\t\t\t\treturn 0\n\t\t\t\n\t\t\tif p: p.close()\n\n\t\t\t# If the object cannot be copied, then we can just return it directly\n\t\t\ttry:\n\t\t\t\tn_dict = {}\n\t\t\t\tfor x in all_n:\n\t\t\t\t\tn_dict[x] = deepcopy(self._primary[x])\n\t\t\t\treturn n_dict\n\t\t\texcept Exception:\n\t\t\t\tn_dict = {}\n\t\t\t\tfor x in all_n:\n\t\t\t\t\tn_dict[x] = self._primary[x]\n\t\t\t\treturn n_dict\n\n\t\t\t# If we explicitly provide a URL, use it, but only in Pyodide (We still assume the file exists on disk when running\n\t\t\t# in server-mode).\n\t\t\tif example_file.startswith(\"https://\"):\n\t\t\t\tn = example_file if Pyodide else str(source + example_file.split(\"/\")[-1])\n\t\t\telse:\n\t\t\t\tn = str(source + example_file)\n\n\t\t\tif n.endswith(wasm_blacklist) and Pyodide:\n\t\t\t\tif p: p.close()\n\t\t\t\treturn 0\n\n\t\t\tif p: p.close()\n\t\t\treturn await self.Download(n)\n\n\t\t# If the application has a unique method of input (IE 3D's ID, don't handle it.)\n\t\telse:\n\t\t\tif p: p.close()\n\t\t\treturn None\n\n\n\tdef Store(self, object, inputs):\n\t\t\"\"\"\n\t\t@brief Store arbitrary data in the Cache.\n\t\t@param object: The object to store\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\th = \"\".join(str(i) for i in inputs)\n\t\tself._objects[h] = object\n\n\n\tdef Get(self, inputs):\n\t\t\"\"\"\n\t\t@brief Retrieve arbitrary data in the Cache.\n\t\t@param inputs: A list of values that compose a hash of the object.\n\t\t\"\"\"\n\t\ttry:\n\t\t\th = \"\".join(str(i) for i in inputs)\n\t\texcept:\n\t\t\treturn None\n\t\tif h in self._objects:\n\t\t\t\treturn self._objects[h]\n\t\telse: return None\n\n\tdef In(self, inputs):\n\t\th = \"\".join(str(i) for i in inputs)\n\t\treturn h in self._objects\n\n\n\tdef Invalidate(self, input):\n\t\tinvalid = []\n\t\tfor key, value in self._objects.items():\n\t\t\tif input in key:\n\t\t\t\tinvalid.append(key)\n\t\tfor i in invalid: del self._objects[i]\n\n\ndef NavBar():\n\t\"\"\"\n\t@brief Returns a Navigation Bar for each project, with the current project selected.\n\t@returns A ui.navset_bar.\n\t\"\"\"\n\n\treturn (\n\t\t#ui.panel_title(title=None, window_title=\"Heatmapper\"),  # added to app.py for each category to display page name\n\t\tui.navset_bar(\n\t\t\tui.nav_control(ui.HTML(f'<a href=\"https://www.safe-hub.ca/\" target=\"_blank\" rel=\"noopener noreferrer\" style=\"font-size: 12pt;\">Home</a>')),\n\t\t\tui.nav_control(ui.HTML('<a href=https://github.com/WishartLab/heatmapper2/wiki target=\"_blank\" rel=\"noopener noreferrer\" style=\"font-size: 12pt;\">About</a>')),\n\t\t\tui.nav_spacer(),\n\t\t\tui.nav_control(ui.input_dark_mode(id=\"mode\")),\n\t\t\ttitle=ui.HTML(\n\t\t\t\tf'<a href=\"{URL}\" target=\"_blank\" rel=\"noopener noreferrer\"> \\\n\t\t\t\t\t<img src=\"{Raw}/site/logo.png\" alt=\"Soil Maps\" width=\"50\"> \\\n\t\t\t\t</a>'),\n\t\t),\n\t)\n\n\ndef FileSelection(examples, types, upload_label=\"Specify a file\", multiple=False, default=\"Upload\", project=\"Overview\", extras=[]):\n\t\"\"\"\n\t@brief Returns the file selection dialog for the user to upload/select an example\n\t@param examples: Either a list of example file names, or a dictionary mapping\n\t@param types: The valid file extensions for user uploaded files.\n\t@param upload_label: The label for the upload input. Useful to define specifically what kind of files are needed\n\t@param multiple: Whether to accept multiple files.\n\t@param default: Whether to start on the example, or upload dialog\n\t@param project: The name of a project, to specify a specified header within the Interface documentation\n\t@param extras: Extra options for giving the application information no render. You are responsible for handling it.\n\t@returns A list, containing the necessary ui components for uploading/selecting\n\t@info The returns elements are named:\n\t\tinput.SourceFile: The ui.input_radio_buttons for whether the user wants to choose an \"Example\" or \"Upload\"\n\t\tinput.File: The ui.input_file for user uploaded files.\n\t\tinput.Example: The ui.input_select for an example file selection\n\t@info multiple=True is not handled properly by the Cache. You will need to create a function that properly handles\n\t\teach file (See spatial for an implementation)\n\t@info If your examples are large files, or require significant computation, you may want to switch it to Upload instead.\n\t\"\"\"\n\n\treturn [\n\t\tui.input_radio_buttons(\n\t\t\tid=\"SourceFile\",\n\t\t\tlabel=None,\n\t\t\tchoices=[\"Example\", \"Upload\"] + extras,\n\t\t\tselected=default,\n\t\t\tinline=True\n\t\t),\n\n\t\t# Only display an input dialog if the user is one Upload\n\t\tui.panel_conditional(\n\t\t\t\"input.SourceFile === 'Upload'\",\n\t\t\tui.input_file(id=\"File\", label=None, accept=types, multiple=multiple),\n\t\t),\n\t\tui.panel_conditional(\n\t\t\t\"input.SourceFile === 'Example'\",\n\t\t\tInlineify(ui.input_select, id=\"Example\", label=ui.input_action_link(id=\"ExampleInfo\", label=\"File Info\"), choices=examples),\n\t\t),\n\t]\n\n\ndef TableOptions(config):\n\t\"\"\"\n\t@brief Return the options for Table Manipulation.\n\t@returns A conditional panel that provides a DataType, and a ResetButton.\n\t\"\"\"\n\treturn  ui.panel_conditional(\n\t\t\"input.MainTab === 'TableTab'\",\n\t\tconfig.Type.UI(ui.input_radio_buttons, make_inline=False, id=\"Type\", label=\"Datatype\", choices=[\"Integer\", \"Float\", \"String\"], inline=True),\n\t\tui.input_action_button(id=\"Reset\", label=\"Reset Values\"),\n\t\t\n\t\tconfig.TableType.UI(ui.input_radio_buttons, make_inline=False, id=\"TableType\", label=\"Download File Type\", choices=[\".txt\", \".csv\", \".tsv\", \".xlsx\"], inline=True),\n\t\tui.download_button(id=\"DownloadTable\", label=\"Download Table\"),\n\t),\n\n\ndef MainTab(*args, m_type=ui.output_plot):\n\treturn ui.navset_tab(\n\t\tui.nav_panel(\"Welcome\",\n\t\t\tui.output_ui(id=\"Welcome\"),\n\t\t\tvalue=\"WelcomeTab\",\n\t\t),\n\t\tui.nav_panel(\"Heatmap\",\n\t\t\t#ui.panel_conditional(\"input.UpdateToggle\", m_type(id=\"Heatmap\", hover=True)),\n\t\t\tui.panel_conditional(\"input.UpdateToggle\", m_type(id=\"Heatmap\")),\n\t\t\tui.panel_conditional(\"!input.UpdateToggle\", m_type(id=\"HeatmapReactive\")),\n\t\t\tvalue=\"HeatmapTab\",\n\t\t),\n\t\tui.nav_panel(\"Table\", \n\t\t\tui.output_data_frame(id=\"Table\"), \n\t\t\tvalue=\"TableTab\",\n\t\t),\n\t\t*args,\n\t\tid=\"MainTab\"\n\t)\n\n\ndef Inlineify(ui_element, widths=[4,8], gap=\"20px\", **kwargs):\n\tlabel = kwargs[\"label\"]\n\tkwargs[\"label\"] = None\n\treturn ui.layout_columns(\n\t\tlabel,\n\t\tui_element(**kwargs),\n\t\tcol_widths=widths,\n\t\tgap=gap,\n\t)\n\nclass Config:\n\t\"\"\"\n\t@brief A configuration entry.\n\t\"\"\"\n\n\tdef __init__(self, visible=True, **kwargs):\n\t\t\"\"\"\n\t\t@brief Create a configuration entry.\n\t\t@param default: The default value for an input.\n\t\t@param visible: Whether the input should be shown in the sidebar\n\t\t@param **kwargs: Arguments to be passed to the input.\n\t\t\"\"\"\n\t\tself.visible = visible\n\t\tself.kwargs = kwargs\n\t\tif \"selected\" in kwargs:\n\t\t\tself.default = kwargs[\"selected\"]\n\t\telif \"value\" in kwargs:\n\t\t\tself.default = kwargs[\"value\"]\n\t\telse:\n\t\t\tself.default = None\n\t\tself.resolve = None\n\n\tdef __call__(self):\n\t\ttry:\n\t\t\tresolved = self.resolve()\n\t\t\treturn self.default if resolved is None else resolved\n\t\texcept Exception:\n\t\t\treturn self.default\n\n\n\tdef Resolve(self, input):\n\t\tself.resolve = input\n\n\n\tdef UI(self, ui_element, make_inline=True, widths=[4,8], gap=\"20px\", conditional=None, *args, **kwargs):\n\t\t\"\"\"\n\t\t@brief Displays the configured UI.\n\t\t@param ui_element The Shiny interface element to use.\n\t\t@param make_inline: Use columns to simulate inline titles for elements that don't support it\n\t\t@param widths: The ratio between the title and the element.\n\t\t@param gap: The gap between the title and element.\n\t\t@param conditional: A conditional JS string.\n\t\t@param **kwargs: Additional arguments to be passed to the input.\n\t\t@note\tkeyword arguments passed to the Config object during initialization will overrule\n\t\t\t\t\targuments passed to this function. Duplicates are allowed.\n\t\t\"\"\"\n\t\tcombined = self.kwargs\n\n\t\tfor key in kwargs.keys():\n\t\t\tcombined[key] = kwargs[key]\n\n\t\tif \"selected\" in combined: combined[\"selected\"] = self()\n\t\telif \"value\" in combined: combined[\"value\"] = self()\n\n\t\t# check for tooltip text\n\t\ttooltip = None\n\t\tif \"tooltip\" in combined:\n\t\t\ttooltip = combined[\"tooltip\"]\n\t\t\tdel combined[\"tooltip\"]\n\n\t\tif self.visible:\n\t\t\tif make_inline and \"label\" in combined:\n\t\t\t\telement = Inlineify(ui_element, widths, gap, **combined)\n\t\t\telse: element = ui_element(*args, **combined)\n\n\t\t\t# display tooltip when user clicks on TooltipIcon\n\t\t\tif tooltip is not None:\n\t\t\t\telement = ui.div(\n\t\t\t\t\telement,\n\t\t\t\t\tui.popover(\n\t\t\t\t\t\tui.span(\n\t\t\t\t\t\t\tTooltipIcon,\n\t\t\t\t\t\t),\n\t\t\t\t\t\ttooltip,\n\t\t\t\t\t\tplacement=\"right\",\n\t\t\t\t\t\tid=combined[\"id\"]+\"_tooltip\" if \"id\" in combined else None,\n\t\t\t\t\t),\n\t\t\t\t\tstyle=\"display: inline-flex; gap: 5px;\",\n\t\t\t\t)\n\n\t\t\t# There doesn't seem any good way to remove the conditional panel spacing.\n\t\t\t# Rather than having conditional configurations stick out due to inconsistent spacing\n\t\t\t# Just give all the panels the same spacing by putting them in true conditions.\n\t\t\treturn ui.panel_conditional(\"1 === 1\" if conditional is None else conditional, element, _add_ws=False)\n\n\nclass ConfigHandler(dict):\n\t\"\"\"\n\t@brief: A dictionary that can be accessed with dots, and can automatically resolve.\n\t\"\"\"\n\n\t__getattr__ = dict.get\n\t__setattr__ = dict.__setitem__\n\t__delattr__ = dict.__delitem__\n\n\n\tdef Resolve(self, input):\n\t\t\"\"\"\n\t\t@brief Resolves all stored objects.\n\t\t@param input The input to use for resolving.\n\t\t\"\"\"\n\t\tfor conf, var in self.items():\n\t\t\tvar.Resolve(input[conf])\n\n\ndef InitializeConfig(config, input):\n\t\"\"\"\n\t@brief Initializes the configuration variable.\n\t@param config: The configuration variable\n\t@param input: The Shiny input\n\n\tThis function will update each configuration's resolve member, so that\n\tif\n\t\"\"\"\n\tfor conf, var in config.items(): var.Resolve(input[conf])\n\n\ndef Error(message, exception=None):\n\tif exception:\n\t\tmessage = f\"{message} due to {type(exception).__name__}: {exception}\"\n\n\treturn ui.notification_show(ui=message, type=\"error\", duration=5)\n\ndef Msg(message): return ui.notification_show(ui=message, type=\"default\", duration=15)\n\n\ndef Update(): return ui.div(\n\tui.input_action_button(\n\t\tid=\"Update\",\n\t\tlabel=ui.layout_columns(\n\t\t\tui.panel_conditional(\"input.UpdateToggle\", \"\"),\n\t\t\t\"Auto Update\",\n\t\t\tui.input_switch(id=\"UpdateToggle\", label=None, value=True),\n\t\t\tcol_widths=[1,9,1],\n\t\t\tgap=\"1px\",\n\t\t\theight=\"1px\", \t# Make it as small as possible\n\t\t)\n\t),\n\tui.popover(\n\t\tui.span(TooltipIcon,),\n\t\t\"When enabled, the heatmap visualization is automatically updated on each setting change. It is recommended to disable Auto Update for large, computationally expensive datasets. When disabled, the Auto Update button must be explicitly clicked to update the visualization.\",\n\t\tplacement=\"right\",\n\t\tid=\"auto_update_tooltip\"\n\t),\n\tstyle=\"display: inline-flex; gap: 5px;\",\n)\n\n\ndef File(input):\n\t# if input.SourceFile() == \"Upload\":\n\t# \treturn \"None\" if input.File() is None else input.File()[0][\"name\"]\n\treturn input.Example()", "type": "text"}]